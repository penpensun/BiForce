/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package biforce.graphs;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Collection;
import java.util.LinkedList;
import java.util.HashMap;

/**
 *
 * @author Administrator
 */
public class BipartiteGraph{
    ArrayList<Vertex> vertices = null;
    //this two variables stores the sizes of vertex set 1 and 2
    private ArrayList<Action> actions = null;
    //This variable stores the cost of the cluster editing.
    private double cost = 0;
    //In new version, we need an array with sizes for each vertex set
    int Set1Size =0;
    int Set2Size = 0;
    
    //EdgeWeight should be represented as HashMap<Integer, Double[]>. Integer is a hashcode generated by 
    //Arrays.hashCode().
    double[][] edgeWeights = null;
    double DefaultValue = -1;
    public final double Permenant = Double.MAX_VALUE;
    public final double Forbidden = -Double.MAX_VALUE;
    
    
    //This variable stores the cluster assignment
    ArrayList<Cluster> clusters = null;

   
    public BipartiteGraph(BipartiteGraph k)
    {
        this.vertices = (ArrayList<Vertex>) k.vertices.clone();
        this.edgeWeights = (double[][])k.edgeWeights.clone();
        this.Set1Size = k.Set1Size;
        this.Set2Size = k.Set2Size;
        actions = new ArrayList();
        clusters = new ArrayList();
    }
    /**
     * This method generates an NpartiteHashMapGraph, using an inputfile
     * @param InputFile
     * @throws IOException 
     * Needs Test
     */
    public BipartiteGraph(String InputFile) throws IOException
    {
        read(InputFile);
        actions = new ArrayList<Action>(0);
        clusters = new ArrayList();
    }
    
    /**
     * This constructor inits the Vertices from an edge weight matrix: EdgeWeights, without given the
     * names of the vertices. The vertices will be names as "R"+ number for rows and "C"+number for columns.
     * @param EdgeWeights 
     */
    public BipartiteGraph(double[][] EdgeWeights)
    {
        //init vertices
        vertices = new ArrayList();
        actions = new ArrayList();
        //first assign the EdgeWeights in this class to the given EdgeWeights
        this.edgeWeights = EdgeWeights;
        //then create vertices for rows
        for(int i=0;i<EdgeWeights.length;i++)
        {
            vertices.add(new Vertex("R"+(i+1),0,i));
        }
        
        //create vertices for columns
        for(int i=0;i<EdgeWeights[0].length;i++)
        {
            vertices.add(new Vertex("C"+(i+1),1,i));
        }
        
        Set1Size = EdgeWeights.length;
        Set2Size = EdgeWeights[0].length;
        actions = new ArrayList();
        clusters = new ArrayList();
    }
    
    /**
     * This constructor inits the graph from the given edge weights, row names, and column names
     * @param EdgeWeights 
     * @param RowNames 
     * @param ColNames 
     */
    public BipartiteGraph(double[][] EdgeWeights, ArrayList<String> RowNames, ArrayList<String> ColNames) 
    {
         //first assign the EdgeWeights in this class to the given EdgeWeights
        this.edgeWeights = EdgeWeights;
        //then create vertices for rows
        for(int i=0;i<EdgeWeights.length;i++)
        {
            vertices.add(new Vertex(RowNames.get(i),0,i));
        }
        
        //create vertices for columns
        for(int i=0;i<EdgeWeights[0].length;i++)
        {
            vertices.add(new Vertex(ColNames.get(i),1,i));
        }
        
        Set1Size = EdgeWeights.length;
        Set2Size = EdgeWeights[0].length;
        actions= new ArrayList();
        clusters = new ArrayList();
    }
    
    /**
     * This method reads information from an inputfile.
     * @param File
     * Needs Test
     * @throws java.io.IOException
     */
    public final void read(String File) throws IOException
    {
        vertices = new ArrayList<Vertex>();
        
        //Read the input file for the first time, to init the 
        //EdgeWeight matrix
        FileReader fr = new FileReader(File);
        BufferedReader br= new BufferedReader(fr);
        String line;
        //no header in the file
        //jump header
        br.readLine();
        
        //Size1, Size2 are two variables just to init EdgeWeight matrix.
        //When the input file is read for the first time, we do not create any vertex or add any vertex into
        //arraylist vertices.
        int Size1 = 0;
        int Size2 = 0;
        
        // Here, we used 2 hashset to count how many vertices we have
        HashSet<String> Set1 = new HashSet<String>();
        HashSet<String> Set2 = new HashSet<String>();
        
        while((line = br.readLine())!= null)
        {
            String[] split  = line.split("\t");
            //if there is only vertex, no other link
            if(split.length ==2)
            {
                
                if(Integer.parseInt(split[1]) == 0 )
                    Set1.add(String.copyValueOf(split[0].toCharArray()));
                else if(Integer.parseInt(split[1]) == 1)
                    Set2.add(String.copyValueOf(split[0].toCharArray()));
                
            }
            else{
                if(Integer.parseInt(split[1]) == 0)
                    Set1.add(String.copyValueOf(split[0].toCharArray()));
                else if(Integer.parseInt(split[1]) == 1)
                    Set2.add(String.copyValueOf(split[0].toCharArray()));

                if(Integer.parseInt(split[3]) == 0)
                    Set1.add(String.copyValueOf(split[2].toCharArray()));
                else if(Integer.parseInt(split[3]) == 1)
                    Set2.add(String.copyValueOf(split[2].toCharArray()));
            }
        }
        br.close();
        fr.close();
        
        Size1 = Set1.size();
        Size2 = Set2.size();
        Set1 = null;
        Set2 = null;
        //U. note: in the new version, we are to implement an npartitegraph based on matrix.
        //Edges between two arbitrarily different vertex sets are permitted.
        //Thus, if we have n vertex sets, we have n(n-1)/2 edge weight matrices
        edgeWeights = new double[Size1][Size2];
        //re-read the file, create vertices and init edge weights.
        fr = new FileReader(File);
        br = new BufferedReader(fr);
        br.readLine();
        while((line = br.readLine())!= null)
        {
            String[] split = line.split("\t");
            //if there is only vertex, no other link
            if(split.length ==2)
            {
            }
            else{
                String Vtx1Name = String.copyValueOf(split[0].toCharArray());
                //int Vtx1Lvl = Integer.parseInt(String.copyValueOf(split[1].toCharArray()));
                int Vtx1Lvl = Integer.parseInt(String.copyValueOf(split[1].toCharArray()));
                String Vtx2Name = String.copyValueOf(split[2].toCharArray());
                //int Vtx2Lvl = Integer.parseInt(String.copyValueOf(split[3].toCharArray()));
                int Vtx2Lvl = Integer.parseInt(String.copyValueOf(split[3].toCharArray()));
                
                //U. note: here it's not proper to use addVertex() just to search for an existing vertex.
                //Thus, we should add a new method findVertex(). maybe a static method in Class Vertex, or a normal
                //method in the new NpartiteGraph class
                int Idx1 = pushVertex(Vtx1Name,Vtx1Lvl);
                int Idx2 = pushVertex(Vtx2Name,Vtx2Lvl);
                double ew = Double.parseDouble(String.copyValueOf(split[4].toCharArray()));
                
                //U. note: here we need a method to assign edgeweight.
                if(Vtx1Lvl == 0 && Vtx2Lvl ==1)
                    edgeWeights[Idx1][Idx2] = ew;
                else if(Vtx1Lvl ==1 && Vtx2Lvl ==0)
                    edgeWeights[Idx2][Idx1] = ew;
                else throw new IllegalArgumentException("Vertex lvl can only be 0 or 1");
            }
        }
        br.close();
        fr.close();
    }
    
    
    public Collection<Vertex> getVertices()
    {
        return this.vertices;
    }
    
    public void setVertices(ArrayList<Vertex> Vertices)
    {
        this.vertices = Vertices;
    }
    
    
    
    /**
     * to get the edge weight of vertex vtx1 and vertex vtx2
     * @param vtx1
     * @param vtx2
     * @return 
     */
    /*
     * U note: in the new version, we have N(N-1)/2 edge weight matrices. To make sure which matrix to store the edge weight
     * we use a hashmap to store all the hashmaps. HashMap<Integer,Double[][]>, the integer is the Arrays.hashCode() of the 
     * vertex set array. A vertex set array is an array of two integers, storing the two sets of the two vertex incident to an
     * edge. The two sets are stored in an ascending order. Then use Arrays.hashCode() to generate the hashcode of the vertex set
     * array. Thus the edge weights between two given vertex set can be stored in its corresponding matrix.
     */
    public double getEdgeWeight(Vertex vtx1, Vertex vtx2)
    {
        if(vtx1.vtxSet == vtx2.vtxSet)
            return 0;
        if(vtx1.vtxSet == 0 && vtx2.vtxSet ==1)
            return edgeWeights[vtx1.getIdx()][vtx2.getIdx()];
        else if(vtx1.vtxSet == 1 && vtx2.vtxSet == 0)
            return edgeWeights[vtx2.getIdx()][vtx1.getIdx()];
        else 
            throw new IllegalArgumentException("Edge level can only be 0 or 1:  "+vtx1.vtxSet+"   "+vtx2.vtxSet);
    }
   
    public double[][] getEdgeWeightMatrix()
    {
        return edgeWeights;
    }
    /*
     * Similarly, we need to have a few lines, judging which matrix we should change the edge weight.
     */
    public void setEdgeWeight(Vertex vtx1,Vertex vtx2, double NewWeight)
    {
          if(vtx1.vtxSet == 0 && vtx2.vtxSet ==1)
            edgeWeights[vtx1.VtxIdx][vtx2.VtxIdx] = NewWeight;
        else if(vtx1.vtxSet == 1 && vtx2.vtxSet == 0)
            edgeWeights[vtx2.getIdx()][vtx1.getIdx()] = NewWeight;
        else 
            throw new IllegalArgumentException("Edge level can only be 0 or 1:  "+vtx1.vtxSet+"   "+vtx2.vtxSet);
    }
    
    public double getPermenant()
    {
        return Permenant;
    }
    
    public double getForbidden()
    {
        return Forbidden;
    }
    
    /**
     * U. Note: 
     * @param VtxName
     * @param VtxLvl
     * @return 
     */
    public int pushVertex(String VtxName, int VtxLvl)
    {
        Vertex vtx = new Vertex(VtxName,VtxLvl,-1);
        //U. Note: we should add a new meothod, searching a vertex in a given
        //vertex list (arrayList or Linkedlist). This method should be a static
        //method
        int Idx = vertices.indexOf(vtx);
        if(Idx == -1)
        {
            vertices.add(vtx);
            //set the index of the new vertex according to its vertex set
            if(VtxLvl == 0)
            {
                vtx.VtxIdx = Set1Size;
                Set1Size++;
                return Set1Size-1;
            }
            else if(VtxLvl ==1)
            {
                vtx.VtxIdx = Set2Size;
                Set2Size++;
                return Set2Size-1;
            }
            else
                throw new IllegalArgumentException("Vertex lvel can only be 0 or 1");
        }
        else
            return vertices.get(Idx).getIdx();
    }
    
   
    
    /**
     * To add new action of vertex vtx1, vertex vtx2.
     * @param vtx1
     * @param vtx2 
     * @param thresh
     */
    public void addAction(Vertex vtx1, Vertex vtx2, double thresh)
    {
        double EdgeWeight = getEdgeWeight(vtx1, vtx2);
        if(EdgeWeight == 0)
            throw new IllegalArgumentException("There is a null-edge between vtx1 and vtx2");
        Action act = new Action(vtx1,vtx2,EdgeWeight);
        actions.add(act);
        if(act.getOriginalWeight() > thresh)
        {
            cost += act.getOriginalWeight() - thresh;
        }
        else
        {
            cost += thresh - act.getOriginalWeight();
        }
    }
    
    /**
     * to carry out the action at given index
     * @param index 
     */
    public void takeAction(int index, double thresh)
    {
        Action act = actions.get(index);
        if(act.getOriginalWeight() > thresh)
        {
            setEdgeWeight(act.getVtx1(),act.getVtx2(),Forbidden);
        }
        else
        {
            setEdgeWeight(act.getVtx1(),act.getVtx2(),Permenant);
        }
    }
    
    /**
     * This method takes all the actions in the action arraylist
     */
    public void takeAllActions(double thresh)
    {
        for(int i=0;i<actions.size();i++)
            takeAction(i, thresh);
    }
    
    /**
     * This method returns true if the action of index idx is already carried out.
     * @param idx
     * @return 
     */
    public boolean isActionCarried(int idx)
    {
        Action act = actions.get(idx);
        if(getEdgeWeight(act.getVtx1(),act.getVtx2()) == Forbidden ||
                getEdgeWeight(act.getVtx1(),act.getVtx2()) == Permenant)
            return true;
        else return false;
    }
    
    /**
     * to get the neighbors of the given seed
     * @param seed
     * @param thresh
     * @return 
     */
    public ArrayList<Vertex> getNeighbors(Vertex seed, double thresh)
    {
        ArrayList<Vertex> Neighbors = new ArrayList();
        for(Vertex vtx: vertices)
        {
            if(getEdgeWeight(vtx,seed) > thresh)
                Neighbors.add(vtx);
        }
        Neighbors.trimToSize();
        return Neighbors;
    }
    
    /**
     * This method returns how many vertices in the graph.
     * @return 
     */
    public int getVertexCount()
    {
        return vertices.size();
    }
    /**
     * 
     * @return 
     */
    public int getSet1Size()
    {
        return this.Set1Size;
    }
    /**
     * 
     * @return 
     */
    public int getSet2Size()
    {
        return this.Set2Size;
    }
    
    /**
     * to return the editing cost.
     * @return 
     */
    public double getCost()
    {
        return cost;
    }
    
    public ArrayList<Cluster> getClusters()
    {
        return clusters;
    }
    public void setClusters(ArrayList<Cluster> clusters)
    {
        this.clusters = clusters;
    }
    public ArrayList<SubBipartiteGraph> getAllConnectedComponents(double thresh) 
    {
        ArrayList<SubBipartiteGraph> AllConnectedComponents = new ArrayList<>();
        //create a indicator LinkedList of vertices, when a vertex is included in one of the subgraphs, then it is 
        //removed from the indicator LinkedList
        LinkedList<Vertex> IndicatorList = new LinkedList<>();
        //add all the vertex into the IndicatorArray
        for(Vertex vtx: getVertices())
        {
            IndicatorList.add(vtx);
        }
        //While there is still unvisited vertex, we use it as the seed to search for subgraphs.
        while(!IndicatorList.isEmpty())
        {
            Vertex Seed = IndicatorList.pollFirst();
            SubBipartiteGraph ConnectedComponent = BFS(Seed,thresh);
            AllConnectedComponents.add(ConnectedComponent);
            //remove all the vertex in the ConnectedComponent from IndicatorList
            for(Vertex vtx: ConnectedComponent.getSubVertexSet())
            {
                IndicatorList.remove(vtx);
            }
        }
        AllConnectedComponents.trimToSize();
        return AllConnectedComponents;
    }
    
    /**
     * 
     * @param Seed
     * @return 
     */
    public SubBipartiteGraph BFS (Vertex Seed, double thresh)
    {
        LinkedList<Vertex> queue = new LinkedList<Vertex>();
        //create a marker
        HashMap<String, Boolean> marker = new HashMap<String,Boolean>();
        //init the haspmap

        //create a new arrayList<Vertex> as result
        ArrayList<Vertex> result = new ArrayList<Vertex>();

        for(Vertex vtx: getVertices())
        {
            marker.put(vtx.toString(), Boolean.FALSE);
        }

        //enqueue source and mark source
         queue.add(Seed);
         result.add(Seed);
         marker.put(Seed.toString(),true);

         //while queue is not empty
         while(!queue.isEmpty())
         {
             //dequeue an item from queue into CurrentVtx
             Vertex CurrentVtx = queue.pollLast();
             //get the neighbours of CurrentVtx
             ArrayList<Vertex> Neighbours = new ArrayList<>(getNeighbors(CurrentVtx,thresh));

             //for each neighbour
             for(Vertex vtx: Neighbours)
             {
                 if(!marker.get(vtx.toString()))
                 {
                     marker.put(vtx.toString(),true);
                     queue.add(vtx);
                     result.add(vtx);
                 }
             }

         }
         //create a new subkpartitegraph
         SubBipartiteGraph sub = new SubBipartiteGraph(result,this);
         return sub;
    }
    
    /**
     * This method outputs the file
     * @param outfile
     * @throws IOException 
     */
    public void writeGraph(String outfile) throws IOException
    {
        BufferedWriter bw = new BufferedWriter(new FileWriter(outfile));
        for(int i=0;i<vertices.size();i++)
        {
            for(int j=i+1;j<vertices.size();j++)
                bw.write(vertices.get(i).Value+"\t"+vertices.get(i).vtxSet+"\t"+
                        vertices.get(j).Value+"\t"+vertices.get(j).vtxSet+"\t"+
                        getEdgeWeight(vertices.get(i),vertices.get(j))+"\r\n");
        }
        bw.flush();
        bw.close();
    }
    
    
    
   
    /**
     * 
     * @param outfile
     * @throws IOException 
     */
    public void writeResult(String outfile) throws IOException
    {
        try {
            BufferedWriter bw = new BufferedWriter(new FileWriter(outfile ,true));
            bw.write("<cost>"+this.getCost()+"<\\cost>\r\n");
            bw.write("<clusters>\r\n");
            for(Cluster cls:clusters)
            {
                if(cls.getVertices().isEmpty())
                    continue;
                for(int i=0;i<cls.getVertices().size()-1;i++)
                    bw.write(cls.getVertices().get(i).Value+",");
                bw.write(cls.getVertices().get(cls.getVertices().size()-1).Value+"\r\n");
            }
            bw.write("<\\clusters>\r\n");
            bw.flush();
        }catch(IOException e){e.printStackTrace();}
    }
    
    
}


